<!DOCTYPE html>
<html lang="en">
 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
 
<body>
 
</body>
</html>
<script>
    /*
     递归:
         函数自己调用自己 停不下来
         需要有 跳出的条件
    /*
        使用递归 求和 1 到 n 的和
        假设 我们 已经封装好了一个函数  fn
        首先找规律
        n=1: 1
        n=2: 1+2   ->fn(1)+2
        n=3: 1+2+3 -->fn(2)+3
        n=4: 1+2+3+4 -->fn(3)+4 -> fn(2)+3+4 -> fn(1)+2+3+4->1+2+3+4
        ..
        n: 1+2+3...+n --> fn(n-1)+n
    */
    function fn(n) {
        if (n == 1) {
            return 1;
        }
        return fn(n - 1) + n;
    }
 
    var result = fn(4);
    console.log(result);
 
 
    /*
        使用递归 求n的阶乘
        假设 写好了一个函数 fn
        1:1
        2:1*2  ->fn(1)*2
        3:1*2*3 ->fn(2)*3
        4:1*2*3*4 ->fn(3)*4
        ...
        n:1*2*3...*n ->fn(n-1)*n
    */
    function fn2(n) {
        // 条件是
        if(n==1){
            return 1;
        }
        return fn2(n - 1) * n;
    }
    var result2 = fn2(4);
    console.log(result2);
 
    /*
        斐波那契数列
        封装好了 函数fn
        十分耗费性能  因为函数成 指数倍 增长 每一个新的函数 都需要耗费 系统的资源
        每一次化简 都需要化到 最底部 1,2 才能够求和
        1:1 fn(1) ->1
        2:1 fn(2) ->1
        3:2 fn(2)+fn(1)
        4:3 fn(3)+fn(2)
        5:5
        6:8
        ....
        n: fn(n-1)+fn(n-2)
    */
    function fn4(n) {
        if (n == 1 || n == 2) {
            return 1;
        }
        return fn4(n - 1) + fn4(n - 2);
    }
    var result = fn4(6);
    console.log(result);
  
</script>